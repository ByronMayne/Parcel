<#@ template debug="false" hostSpecific="false" linePragmas="false" visibility="public" #>
<#@ output extension=".cs" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO"#>
<#@ import namespace="UnityEngine"#>
<#@ import namespace="UnityEditor"#>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ parameter name="m_Bundles" type="UnityEditor.AssetBundleBuild[]"#>

using UnityEngine;
#if UNITY_EDITOR
using UnityEditor; 
#endif
using System.Collections;
using System.Collections.Generic;

namespace ParcelTool
{
	public delegate void OnAssetDownloadCompleteDelegate<T>( T asset );
	public delegate void AssetRequestDelegate();

	public static class ParcelBundles
	{
	    /// <summary>
        /// If true in the editor at play mode we will load using Asset Bundles
        /// instead of the Asset Database. It is much quicker to use Asset Database. 
        /// </summary>
	    public static bool UseBundlesInEditor = false;
        public static bool UseAssetDatabaseToLoad
        {
            get
            {

#if UNITY_EDITOR
                if(EditorApplication.isPlayingOrWillChangePlaymode)
                {
                    return UseBundlesInEditor; 
                }
#endif
                return false;
            }
        }

<# for( int x = 0; x < m_Bundles.Length; x++) 
   {
	   AssetMeta[] m_BundleMeta = new AssetMeta[m_Bundles[x].assetNames.Length];

	   for(int y = 0; y < m_BundleMeta.Length; y++)
       {
		   // Create a new bundle item for each of our files. 
		   m_BundleMeta[y] = new AssetMeta(m_Bundles[x].assetNames[y]); 
       }

	   // Write our new class
		WriteLine("public static class {0} ", m_Bundles[x].assetBundleName);
		WriteLine("{");
		PushIndent("  ");
		{
			// Write Fields
			WriteLine("private const string m_BundleName = \"{0}\";", m_Bundles[x].assetBundleName);
			WriteLine("private static AssetBundle m_Bundle;");
			WriteLine("private static IBundleDownloader m_BundleDownloader;");
			WriteLine("private static List<AssetRequestDelegate> m_QueueAssetRequests = new List<AssetRequestDelegate>();");
			WriteLine("// Cached Objects");
	    	ForEach( m_BundleMeta, WriteFiled);

			// Write Properties
			ForEach( m_BundleMeta, WriteProperty);

			// Write Functions 
			WriteBundleFunctions(m_Bundles[x].assetBundleName);
        }
		PopIndent();
		WriteLine("}");
   }
#>
	}
}

<#+ 
/// <summary>
/// Used to write the field for each asset meta. 
/// </summary>
public void WriteFiled(AssetMeta meta)
{
#>
	private static <#= meta.typeName #> m_<#= meta.name #> = null;
<#+
} 


public void WriteBundleFunctions(string bundleName)
{
#>
	public static void DownloadBundle(IBundleDownloader bundleDownloader)
	{
		 m_BundleDownloader = bundleDownloader;
	     bundleDownloader.StartCoroutine(DownloadBundleRoutine());
	}
	
	private static IEnumerator DownloadBundleRoutine()
	{
	  WWW www = WWW.LoadFromCacheOrDownload(m_BundleDownloader.GetBundleURL(m_BundleName), 0);
	  do
	  {
	    yield return new WaitForEndOfFrame();
	    m_BundleDownloader.OnBundleDownloadProgressUpdated(m_BundleName, www.progress);
	  } while (!www.isDone);
	
	  if(string.IsNullOrEmpty(www.error))
	  {
		m_BundleDownloader.OnBundleDownloadComplete(m_BundleName);
		m_Bundle = www.assetBundle;
	
		// Fire off all requests.
		for( int i = 0; i < m_QueueAssetRequests.Count; i++)
		{
			m_QueueAssetRequests[i](); 
		}
		m_QueueAssetRequests.Clear();
	  }
	  else
	  {
	    m_BundleDownloader.OnBundleDownloadFailed(m_BundleName, www.url, www.error);
		m_Bundle = null;
	  }
	
	
	}

  	public static void UnloadBundle(MonoBehaviour coroutineRunner)
	{

	}
<#+
}

/// <summary>
/// Used to write the property for each asset meta. 
/// </summary>
public void WriteProperty(AssetMeta meta)
{
#> 

public static void Get<#= meta.name #>(OnAssetDownloadCompleteDelegate<<#=meta.typeName#>> assignmentFunction)
{
	if( m_Bundle != null )
	{
		if( assignmentFunction != null )
		{
			assignmentFunction( Get<#= meta.name #>() ); 
		}
		else
		{
			m_QueueAssetRequests.Add( () => { assignmentFunction( Get<#= meta.name #>() ); } );
		}
	}
}

public static <#= meta.typeName #> Get<#= meta.name #>() 
{
	if( m_<#= meta.name #> == null )
	{
#if UNITY_EDITOR
		if(ParcelBundles.UseAssetDatabaseToLoad)
		{
			m_<#= meta.name #> = AssetDatabase.LoadAssetAtPath<<#= meta.typeName #>>( "<#= meta.fullPath #>" );
			return m_<#= meta.name #>;
		}
#endif
<#+ if ( meta.isResourceItem ) { #>
		m_<#= meta.name #> = Resources.Load<<#= meta.typeName #>>( "<#= meta.assetPath #>" );
<#+ } else { #>
		m_<#= meta.name #> = m_Bundle.LoadAsset<<#= meta.typeName #>>( "<#= meta.assetPath #>" );
<#+}#>
	}
	return m_<#= meta.name #>;
}
<#+
}


public void ForEach( AssetMeta[] bundleMetaArray, System.Action<AssetMeta> action )
{
	for(int i = 0; i < bundleMetaArray.Length; i++)
    {
		action(bundleMetaArray[i]);
    }
}

/// <summary>
/// Used to setup all the strings we need to write for each asset. 
/// </summary>
public struct AssetMeta
{
	private string m_Typename; 
	private string m_AssetPath;
	private string m_Fullpath;
	private string m_Name;
	private bool m_IsResourceItem;

	public AssetMeta(string fullPath)
    {
		m_Fullpath = fullPath;
		UnityEngine.Object asset =  AssetDatabase.LoadAssetAtPath<UnityEngine.Object>(fullPath);
		m_Typename = asset.GetType().Name; 

		m_IsResourceItem = m_Fullpath.Contains("/Resources/");
		m_Name = Path.GetFileNameWithoutExtension(m_Fullpath);

		if(m_IsResourceItem)
        {
			int pathIndex = m_Fullpath.IndexOf("/Resources/") + 11 /* 11 is how many chars the resources folder is */;
			m_AssetPath = m_Fullpath.Substring(pathIndex, fullPath.Length - pathIndex);
		    m_AssetPath = m_AssetPath.Replace(Path.GetExtension(m_AssetPath), string.Empty);
        }
		else
        {
			m_AssetPath = m_Name;
        }

    }

	public bool isResourceItem
    {
		get
        {
			return m_IsResourceItem;
        }
    }

	public string name
    {
		get
        {
			return m_Name;
        }
    }

	public string typeName
    {
		get
        {
			return m_Typename;
        }
    }

	public string fullPath
    {
		get 
        {
			return m_Fullpath; 
        }
    }

	public string assetPath
    {
		get
        {
			return m_AssetPath;
        }
    }


}
	
#>